name: CI

on:
  push:
    branches: [main, develop, canonical-main-v2]
  pull_request:
    branches: [main, develop, canonical-main-v2]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: '22'
  PNPM_VERSION: '8'

jobs:
  # Security guard - fail if forbidden files are committed
  secrets-guard:
    name: Secrets Guard
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for forbidden files
        run: |
          echo "Checking for forbidden files in repository..."
          FORBIDDEN_FILES=""

          # Check for .env files (excluding .env.example)
          if git ls-files | grep -E "^\.env$|^\.env\.[^e]|apps/.*\.env$|packages/.*\.env$" | grep -v ".env.example"; then
            FORBIDDEN_FILES="$FORBIDDEN_FILES .env files found!"
          fi

          # Check for .turbo cache directories
          if git ls-files | grep -E "\.turbo/"; then
            FORBIDDEN_FILES="$FORBIDDEN_FILES .turbo cache found!"
          fi

          # Check for private keys
          if git ls-files | grep -E "\.(pem|key)$"; then
            FORBIDDEN_FILES="$FORBIDDEN_FILES Private key files found!"
          fi

          # Check for secrets directories
          if git ls-files | grep -E "^secrets/"; then
            FORBIDDEN_FILES="$FORBIDDEN_FILES Secrets directory found!"
          fi

          if [ -n "$FORBIDDEN_FILES" ]; then
            echo "::error::SECURITY VIOLATION: Forbidden files detected in repository!"
            echo "$FORBIDDEN_FILES"
            exit 1
          fi

          echo "✓ No forbidden files detected"

  lint:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm db:generate

      - name: Lint
        run: pnpm lint

      - name: Type Check
        run: pnpm typecheck

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: realriches_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm db:generate

      - name: Run migrations
        run: pnpm db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/realriches_test?schema=public

      - name: Run tests
        run: pnpm test:coverage
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/realriches_test?schema=public
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: test-jwt-secret-for-ci-only-min-32-chars
          ENCRYPTION_KEY: test-encryption-key-32-bytes-xx

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          fail_ci_if_error: false

  acceptance-tests:
    name: Acceptance Tests
    runs-on: ubuntu-latest
    needs: [lint, test]
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: realriches_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm db:generate

      - name: Run migrations
        run: pnpm db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/realriches_test?schema=public

      - name: Build packages
        run: pnpm build

      - name: Run acceptance tests
        run: pnpm test:acceptance
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/realriches_test?schema=public
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: test-jwt-secret-for-ci-only-min-32-chars
          ENCRYPTION_KEY: test-encryption-key-32-bytes-xx

      - name: Upload acceptance report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: acceptance-report
          path: apps/api/reports/acceptance-report.json
          retention-days: 30

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [secrets-guard, lint, test, acceptance-tests]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm db:generate

      - name: Build
        run: pnpm build

      - name: Upload API build
        uses: actions/upload-artifact@v4
        with:
          name: api-build
          path: apps/api/dist
          retention-days: 7

      - name: Upload Web build
        uses: actions/upload-artifact@v4
        with:
          name: web-build
          path: apps/web/.next
          retention-days: 7

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check security headers configuration
        run: ./scripts/check-security-headers.sh

      - name: Check authorization middleware
        run: ./scripts/check-auth-middleware.sh

      - name: Audit dependencies
        run: pnpm audit --audit-level moderate
        continue-on-error: true

      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  traceability-check:
    name: Traceability Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate Master Implementation Ledger
        run: |
          echo "Validating Master Implementation Ledger..."
          LEDGER_FILE="docs/traceability/MASTER_IMPLEMENTATION_LEDGER.md"

          # Check file exists
          if [ ! -f "$LEDGER_FILE" ]; then
            echo "::error::TRACEABILITY VIOLATION: $LEDGER_FILE does not exist!"
            exit 1
          fi
          echo "✓ Ledger file exists"

          # Check required sections exist
          REQUIRED_SECTIONS=(
            "## 1. Compliance"
            "## 2. Revenue Partners"
            "## 3. Document Vault"
            "## 4. AI Agents"
            "## 5. Agent Governance"
            "## 6. Media Generation"
            "## 7. 3D Tours"
            "## 8. Mobile"
            "## 9. Security"
            "## 10. Multi-Market"
            "## 11. Observability"
            "## 12. Workflows"
          )

          MISSING_SECTIONS=""
          for section in "${REQUIRED_SECTIONS[@]}"; do
            if ! grep -q "$section" "$LEDGER_FILE"; then
              MISSING_SECTIONS="$MISSING_SECTIONS\n  - $section"
            fi
          done

          if [ -n "$MISSING_SECTIONS" ]; then
            echo "::error::TRACEABILITY VIOLATION: Missing required sections in ledger:$MISSING_SECTIONS"
            exit 1
          fi
          echo "✓ All required sections present"

          # Check for TBD/TODO placeholders
          if grep -E "(TBD|TODO|PLACEHOLDER|FIXME)" "$LEDGER_FILE"; then
            echo "::error::TRACEABILITY VIOLATION: Ledger contains unresolved placeholders (TBD/TODO/PLACEHOLDER/FIXME)"
            exit 1
          fi
          echo "✓ No unresolved placeholders"

          # Check for summary statistics section
          if ! grep -q "## Summary Statistics" "$LEDGER_FILE"; then
            echo "::error::TRACEABILITY VIOLATION: Missing Summary Statistics section"
            exit 1
          fi
          echo "✓ Summary Statistics section present"

          echo ""
          echo "✅ Master Implementation Ledger validation passed!"

      - name: Validate Gap Register
        run: |
          echo "Validating Gap Register..."
          GAP_FILE="docs/traceability/GAP_REGISTER.md"

          # Check file exists
          if [ ! -f "$GAP_FILE" ]; then
            echo "::error::TRACEABILITY VIOLATION: $GAP_FILE does not exist!"
            exit 1
          fi
          echo "✓ Gap Register file exists"

          # Check required sections exist
          if ! grep -q "## Gap Summary" "$GAP_FILE"; then
            echo "::error::TRACEABILITY VIOLATION: Missing Gap Summary section"
            exit 1
          fi
          echo "✓ Gap Summary section present"

          if ! grep -q "## Detailed Gap Analysis" "$GAP_FILE"; then
            echo "::error::TRACEABILITY VIOLATION: Missing Detailed Gap Analysis section"
            exit 1
          fi
          echo "✓ Detailed Gap Analysis section present"

          if ! grep -q "## Remediation Timeline" "$GAP_FILE"; then
            echo "::error::TRACEABILITY VIOLATION: Missing Remediation Timeline section"
            exit 1
          fi
          echo "✓ Remediation Timeline section present"

          # Check for TBD/TODO placeholders in gap descriptions
          if grep -E "^#### Description$" -A 5 "$GAP_FILE" | grep -E "(TBD|TODO|PLACEHOLDER)"; then
            echo "::error::TRACEABILITY VIOLATION: Gap Register contains unresolved placeholders in descriptions"
            exit 1
          fi
          echo "✓ No unresolved placeholders in gap descriptions"

          echo ""
          echo "✅ Gap Register validation passed!"

      - name: Cross-reference check
        run: |
          echo "Checking cross-references between STATUS_REPORT.md and traceability docs..."

          # Check STATUS_REPORT.md references the ledger and gap register
          if ! grep -q "MASTER_IMPLEMENTATION_LEDGER.md" "STATUS_REPORT.md"; then
            echo "::error::TRACEABILITY VIOLATION: STATUS_REPORT.md does not reference Master Implementation Ledger"
            exit 1
          fi
          echo "✓ STATUS_REPORT.md references Master Implementation Ledger"

          if ! grep -q "GAP_REGISTER.md" "STATUS_REPORT.md"; then
            echo "::error::TRACEABILITY VIOLATION: STATUS_REPORT.md does not reference Gap Register"
            exit 1
          fi
          echo "✓ STATUS_REPORT.md references Gap Register"

          echo ""
          echo "✅ Cross-reference check passed!"

      - name: Summary
        run: |
          echo ""
          echo "=========================================="
          echo "  TRACEABILITY CHECK COMPLETE"
          echo "=========================================="
          echo ""
          echo "All traceability documentation is valid:"
          echo "  ✓ Master Implementation Ledger"
          echo "  ✓ Gap Register"
          echo "  ✓ Cross-references"
          echo ""

  persistence-guard:
    name: Persistence Guard
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm db:generate

      - name: Verify no InMemory imports in production code
        run: |
          echo "Checking for forbidden InMemory imports in production code..."

          # Check for direct InMemory class instantiation in production routes
          if grep -r "new InMemory" apps/api/src/modules/ 2>/dev/null; then
            echo "::error::PERSISTENCE VIOLATION: Found 'new InMemory*' in production routes!"
            echo "Use the persistence composition root (apps/api/src/persistence) instead."
            exit 1
          fi
          echo "✓ No InMemory instantiation in routes"

          # Check for InMemory imports in production routes
          if grep -r "InMemoryAttributionStore\|InMemoryMeteringService" apps/api/src/modules/ 2>/dev/null; then
            echo "::error::PERSISTENCE VIOLATION: Found InMemory imports in production routes!"
            echo "Use getAttributionStore()/getMeteringService() from persistence composition root."
            exit 1
          fi
          echo "✓ No InMemory imports in routes"

          # Verify composition root exists
          if [ ! -f "apps/api/src/persistence/index.ts" ]; then
            echo "::error::PERSISTENCE VIOLATION: Composition root not found!"
            exit 1
          fi
          echo "✓ Composition root exists"

          # Verify composition root uses dynamic imports for test stores
          if grep -E "^import.*InMemory" apps/api/src/persistence/index.ts 2>/dev/null; then
            echo "::error::PERSISTENCE VIOLATION: Composition root has static InMemory imports!"
            echo "InMemory stores must be dynamically imported in test mode only."
            exit 1
          fi
          echo "✓ Composition root uses dynamic imports for InMemory stores"

          echo ""
          echo "✅ Persistence guard check passed!"

      - name: Run persistence guard tests
        run: cd apps/api && npx vitest run -c vitest.persistence.config.ts
        env:
          NODE_ENV: test

      - name: Summary
        run: |
          echo ""
          echo "=========================================="
          echo "  PERSISTENCE GUARD COMPLETE"
          echo "=========================================="
          echo ""
          echo "Verified:"
          echo "  ✓ No InMemory stores in production code"
          echo "  ✓ Composition root properly configured"
          echo "  ✓ Dynamic imports for test-only stores"
          echo ""

  ops-runbooks:
    name: Ops Runbook Validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate runbook files exist
        run: |
          echo "Checking for required runbook files..."
          MISSING=""

          REQUIRED_FILES=(
            "docs/ops/backup-strategy.md"
            "docs/ops/restore-steps.md"
            "docs/ops/restore-drill.md"
            "docs/ops/incident-response.md"
            "docs/ops/rollback-plan.md"
          )

          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              MISSING="$MISSING\n  - $file"
            else
              echo "✓ Found: $file"
            fi
          done

          if [ -n "$MISSING" ]; then
            echo "::error::Missing required runbook files:$MISSING"
            exit 1
          fi

          echo "✓ All required runbook files exist"

      - name: Validate backup-strategy.md headings
        run: |
          echo "Validating backup-strategy.md..."
          FILE="docs/ops/backup-strategy.md"

          REQUIRED_HEADINGS=(
            "## Overview"
            "## Backup Types"
            "## Recovery Point Objective"
            "## Recovery Time Objective"
            "## Retention Policy"
          )

          for heading in "${REQUIRED_HEADINGS[@]}"; do
            if ! grep -q "$heading" "$FILE"; then
              echo "::error::Missing required heading in $FILE: $heading"
              exit 1
            fi
            echo "✓ Found: $heading"
          done

          echo "✓ backup-strategy.md validation passed"

      - name: Validate restore-steps.md headings
        run: |
          echo "Validating restore-steps.md..."
          FILE="docs/ops/restore-steps.md"

          REQUIRED_HEADINGS=(
            "## Overview"
            "## Prerequisites"
            "## Restore Scenarios"
            "## Post-Restore Checklist"
          )

          for heading in "${REQUIRED_HEADINGS[@]}"; do
            if ! grep -q "$heading" "$FILE"; then
              echo "::error::Missing required heading in $FILE: $heading"
              exit 1
            fi
            echo "✓ Found: $heading"
          done

          echo "✓ restore-steps.md validation passed"

      - name: Validate incident-response.md headings
        run: |
          echo "Validating incident-response.md..."
          FILE="docs/ops/incident-response.md"

          REQUIRED_HEADINGS=(
            "## Overview"
            "## Severity Levels"
            "## Escalation Matrix"
          )

          for heading in "${REQUIRED_HEADINGS[@]}"; do
            if ! grep -q "$heading" "$FILE"; then
              echo "::error::Missing required heading in $FILE: $heading"
              exit 1
            fi
            echo "✓ Found: $heading"
          done

          echo "✓ incident-response.md validation passed"

      - name: Validate rollback-plan.md headings
        run: |
          echo "Validating rollback-plan.md..."
          FILE="docs/ops/rollback-plan.md"

          REQUIRED_HEADINGS=(
            "## Overview"
            "## Application Rollback"
            "## Database Rollback"
            "## Rollback Verification"
          )

          for heading in "${REQUIRED_HEADINGS[@]}"; do
            if ! grep -q "$heading" "$FILE"; then
              echo "::error::Missing required heading in $FILE: $heading"
              exit 1
            fi
            echo "✓ Found: $heading"
          done

          echo "✓ rollback-plan.md validation passed"

      - name: Summary
        run: |
          echo ""
          echo "=========================================="
          echo "  OPS RUNBOOK VALIDATION COMPLETE"
          echo "=========================================="
          echo ""
          echo "Validated:"
          echo "  ✓ backup-strategy.md"
          echo "  ✓ restore-steps.md"
          echo "  ✓ restore-drill.md"
          echo "  ✓ incident-response.md"
          echo "  ✓ rollback-plan.md"
          echo ""

  ops-scripts:
    name: Ops Scripts Validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify ops scripts are executable
        run: |
          echo "Checking ops scripts are executable..."
          FAILED=""

          SCRIPTS=(
            "scripts/ops/verify-backups.sh"
            "scripts/ops/generate-restore-checklist.sh"
          )

          for script in "${SCRIPTS[@]}"; do
            if [ ! -f "$script" ]; then
              echo "::error::Missing script: $script"
              FAILED="$FAILED\n  - $script (missing)"
            elif [ ! -x "$script" ]; then
              echo "::error::Script not executable: $script"
              FAILED="$FAILED\n  - $script (not executable)"
            else
              echo "✓ Executable: $script"
            fi
          done

          if [ -n "$FAILED" ]; then
            echo "::error::Script validation failed:$FAILED"
            exit 1
          fi

          echo "✓ All ops scripts are executable"

      - name: Test verify-backups.sh syntax
        run: |
          echo "Testing verify-backups.sh syntax..."
          bash -n scripts/ops/verify-backups.sh
          echo "✓ verify-backups.sh syntax is valid"

      - name: Test generate-restore-checklist.sh syntax
        run: |
          echo "Testing generate-restore-checklist.sh syntax..."
          bash -n scripts/ops/generate-restore-checklist.sh
          echo "✓ generate-restore-checklist.sh syntax is valid"

      - name: Run verify-backups.sh in CI mode
        run: |
          echo "Running verify-backups.sh in CI mode..."
          CI=true ./scripts/ops/verify-backups.sh --verbose
          echo "✓ verify-backups.sh runs successfully"

      - name: Run generate-restore-checklist.sh
        run: |
          echo "Running generate-restore-checklist.sh..."
          ./scripts/ops/generate-restore-checklist.sh > /tmp/checklist.md
          if [ -s /tmp/checklist.md ]; then
            echo "✓ Checklist generated successfully"
            head -20 /tmp/checklist.md
          else
            echo "::error::Checklist generation produced empty output"
            exit 1
          fi

      - name: Summary
        run: |
          echo ""
          echo "=========================================="
          echo "  OPS SCRIPTS VALIDATION COMPLETE"
          echo "=========================================="
          echo ""
          echo "Validated:"
          echo "  ✓ verify-backups.sh"
          echo "  ✓ generate-restore-checklist.sh"
          echo ""

  # Performance regression detection
  performance:
    name: Performance Smoke Test
    runs-on: ubuntu-latest
    # Only run on main branch to avoid flaky PR checks
    # PRs can trigger manually via workflow_dispatch
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Verify k6 installation
        run: k6 version

      - name: Validate baselines.json
        run: |
          echo "Validating performance baselines..."
          if [ ! -f tests/performance/baselines.json ]; then
            echo "::error::baselines.json not found"
            exit 1
          fi

          # Validate JSON syntax
          if ! jq empty tests/performance/baselines.json 2>/dev/null; then
            echo "::error::baselines.json is not valid JSON"
            exit 1
          fi

          # Validate required fields
          VERSION=$(jq -r '.version' tests/performance/baselines.json)
          if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
            echo "::error::baselines.json missing version field"
            exit 1
          fi

          echo "✓ baselines.json is valid (v$VERSION)"

      - name: Validate k6 test syntax
        run: |
          echo "Validating k6 test scripts..."

          # Check smoke.js syntax
          k6 inspect tests/performance/smoke.js > /dev/null
          echo "✓ smoke.js syntax is valid"

          # Check individual test files
          for file in tests/performance/listing-*.js tests/performance/application-*.js tests/performance/signed-*.js; do
            if [ -f "$file" ]; then
              k6 inspect "$file" > /dev/null
              echo "✓ $(basename $file) syntax is valid"
            fi
          done

      - name: Run smoke test (dry run)
        run: |
          echo "Running k6 smoke test in dry-run mode..."
          echo ""

          # Load baselines
          BASELINES=$(cat tests/performance/baselines.json)

          # Run k6 with very short duration for CI validation
          # This validates the test structure without needing a real API
          k6 run \
            --env "API_BASE_URL=http://localhost:4000" \
            --env "AUTH_TOKEN=ci-test-token" \
            --env "BASELINES=$BASELINES" \
            --duration 1s \
            --vus 1 \
            --no-thresholds \
            tests/performance/smoke.js 2>&1 || true

          echo ""
          echo "✓ Smoke test structure validated"

      - name: Validate run-smoke.sh script
        run: |
          echo "Validating run-smoke.sh script..."

          if [ ! -f scripts/perf/run-smoke.sh ]; then
            echo "::error::run-smoke.sh not found"
            exit 1
          fi

          if [ ! -x scripts/perf/run-smoke.sh ]; then
            echo "::error::run-smoke.sh is not executable"
            exit 1
          fi

          bash -n scripts/perf/run-smoke.sh
          echo "✓ run-smoke.sh syntax is valid"

      - name: Summary
        run: |
          echo ""
          echo "=========================================="
          echo "  PERFORMANCE TESTS VALIDATED"
          echo "=========================================="
          echo ""
          echo "Validated:"
          echo "  ✓ baselines.json (thresholds config)"
          echo "  ✓ smoke.js (main test runner)"
          echo "  ✓ Individual endpoint tests"
          echo "  ✓ run-smoke.sh script"
          echo ""
          echo "To run full performance tests:"
          echo "  ./scripts/perf/run-smoke.sh --api-url http://your-api:4000"
          echo ""
